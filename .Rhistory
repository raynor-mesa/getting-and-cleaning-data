install.packages("devtools")
library(devtools)
find_rtools()
install.packages("KernSmooth")
library(KernSmooth)
add2 <- function(x, y) {}
add2 <- function(x, y) {x + y}
add2(1,1)
add2(1,2)
above <- function(x, n) {
use <- x > n
x[use]
}
x <- 1:10
above(x, 5)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
x <- 1:20
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[,i])
}
means
}
library(datasets)
data(iris)
?iris
iris
tapply(iris, gl = (3, 1, labels = c(setosa, versicolor, virginia)), mean)
tapply("iris", gl = (3, 1, labels = c(setosa, versicolor, virginia)), mean)
tapply(iris, gl(3, 1, labels = c(setosa, versicolor, virginia)), mean)
iris$Species
tapply(iris, gl(3, 1, labels = c("setosa", "versicolor", "virginica")), mean)
tapply(iris, gl(3, 1), mean)
f <- gl(3, 1)
f
f <- gl(3, 1, labels = c("setosa", "versicolor", "virginica"))
f
tapply(iris, f, mean)
x <- iris
tapply(x, f, mean)
tapply(iris$Sepal.Length, f, mean)
is.atomic(iris)
is.atomic(iris$Sepal.Length)
tapply(iris$Sepal.Length, f, mean)
f
f <- list("setosa", "versicolor", "virginica")
tapply(iris$Sepal.Length, f, mean)
tapply(iris$Sepal.Length, INDEX = f, mean)
f <- gl(3,1)
tapply(iris$Sepal.Length, INDEX = f, mean)
debug
is.vector(iris$Sepal.Length)
is.factor(f)
f <- gl(3, 50)
tapply(iris$Sepal.Length, INDEX = f, mean)
colMeans(iris)
iris
apply(iris[,1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
mtcars
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
with(mtcars, tapply(mpg, cyl, mean))
sapply(split(mtcars$mpg, mtcars$cyl), mean)
15.1-26.66364
debug(ls)
ls
debug
debug(ls)
ls
ls
ls
ls
debug
ls
debug(ls)
exit
ls
ls
debug(ls)
ls
debug(ls)
ls
exit
1
2
debug
library(datasets)
data("iris")
tapply(iris$Sepal.Length, iris$Species, mean)
data(mtcars)
x <- tapply(mtcars$mpg, mtcars$cyl, mean)
x
x[4] - x[2]
x[4]
x
15.1-26.7
mtars
mtcars
x <- tapply(mtcars$hp, mtcars$cyl, mean)
x
209.21429-82.63636
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y = matrix()) {
x <<- y
cache <<- NULL
}
get <- function() x
setcache <- function(solve) cache <<- solve
getcache <- function() cache
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
cache <- x$getcache()
if(!is.null(cache)) {
message("Retrieving cached inverse")
return(cache)
}
matrix <- x$get()
cache <- solve(matrix, ...)
x$setcahce(cache)
## Return a matrix that is the inverse of 'x'
}
a <- matrix(1:1000, 1, 1000)
a
makeCacheMatrix(x)
x <- makeCacheMatrix(a)
x
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y = matrix()) {
x <<- y
cache <<- NULL
}
get <- function() {
x
}
setcache <- function(solve) {
cache <<- solve
}
getcache <- function() {
cache
}
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
x <- makeCacheMatrix(a)
x
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y) {
x <<- y
cache <<- NULL
}
get <- function() {
x
}
setcache <- function(solve) {
cache <<- solve
}
getcache <- function() {
cache
}
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
x <- makeCacheMatrix(a)
x
x$set(a)
x
x$set
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(1:2)
v <- makeVector(1:2)
v
v$get()
a$get()
x$get()
x$getcache()
makeCacheMatrix()
x <- makeCacheMatrix()
x$set(a)
x$getcache()
x$setcache(a)
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y) {
x <<- y
cache <<- NULL
}
get <- function() {
x
}
setcache <- function(solve) {
cache <<- solve(solve)
}
getcache <- function() {
cache
}
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
cache <- x$getcache()
if(!is.null(cache)) {
message("Retrieving cached inverse")
return(cache)
}
matrix <- x$get()
cache <- solve(matrix, ...)
x$setcahce(cache)
## Return a matrix that is the inverse of 'x'
}
x <- makeCacheMatrix()
x$set(a)
x$setcache(a)
a <- matrix(1:10000, 100, 100)
x$set(a)
x$setcache(a)
a
solve(a)
a(c(1:5000, 5000:1), 100, 100)
a <- matrix(c(1:5000, 5000:1), 100, 100)
a
x
x$set(a)
x$setcache(a)
a <- matrix(c(135, 668, 777, 69), 2, 2)
a
x$set(a)
x$setcache(a)
x$getcache()
cacheSolve(a)
cacheSolve(x)
b <- matrix(c(564, 7894, 453, 956), 2, 2)
makeCacheMatrix(b)
y <- makeCacheMatrix(b)
b
y$get()
cacheSolve(y)
## makeCacheMatrix creates a list of functions that can store a matrix and
## its inverse. cacheSolve can retrieve a stored inverse from a cacheMatrix,
## or solve for the inverse and then store it.
## Create a list to store a matrix and cache its inverse, as well as
## functions to set a new matrix and its corresponding inverse
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y) {
x <<- y
cache <<- NULL
}
get <- function() {
x
}
setcache <- function(solve) {
cache <<- solve(solve)
}
getcache <- function() {
cache
}
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
## Returns a cacheMatrix's stored inverse matrix, or solves for the inverse
## if one has not been solved prior
cacheSolve <- function(x, ...) {
cache <- x$getcache()
if(!is.null(cache)) {
message("Retrieviorng cached inverse")
return(cache)
}
matrix <- x$get()
cache <- solve(matrix, ...)
x$setcache(cache)
cache
## Return a matrix that is the inverse of 'x'
}
cacheSolve(y)
y$getcache()
y
y$get()
y$getcache()
y <- makeCacheMatrix(b)
y$getcache()
cacheSolve(y)
y$getcache
y$getcache()
y$setcache(b)
y$getcache()
## makeCacheMatrix creates a list of functions that can store a matrix and
## its inverse. cacheSolve can retrieve a stored inverse from a cacheMatrix,
## or solve for the inverse and then store it.
## Create a list of functions to store and retrieve a matrix and its inverse
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
set <- function(y) {
x <<- y
cache <<- NULL
}
get <- function() {
x
}
setcache <- function(inverse) {
cache <<- inverse
}
getcache <- function() {
cache
}
list(set = set, get = get, setcache = setcache, getcache = getcache)
}
## Returns a cacheMatrix's stored inverse matrix, or solves for the inverse
## if one has not been solved prior
cacheSolve <- function(x, ...) {
cache <- x$getcache()
if(!is.null(cache)) {
message("Retrieviorng cached inverse")
return(cache)
}
matrix <- x$get()
cache <- solve(matrix, ...)
x$setcache(cache)
cache
## Return a matrix that is the inverse of 'x'
}
a <- matrix(c(2132321, 456458, 651623, 456456), 2, 2)
x <- makeCacheMatrix(a)
x$get()
x$getcache()
cacheSolve(x)
x$getcache()
test <- makeCacheMatrix(a)
test
test$get()
set.seed(10)
set.seed(1)
rpois(5,2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
R.home()
install.packages("RMySQL", type = "source")
source("http://bioconductor.org/biocLite.R")
biocLite("rhdf5")
setwd("Coursera/Data Science 3 - Getting and Cleaning Data/UCI HAR Dataset")
source("run_analysis.r")
str(extracted)
source("run_analysis.r")
source("run_analysis.r")
length(labe)
length(label)
length(vars2)
vars2[3]
length(colnames(extracted))
colnames(extracted)[3]
source("run_analysis.r")
source("run_analysis.r")
names(extracted)
labels
source("run_analysis.r")
str(extracted)
head(extracted)
f <- as.factor(extracted$SUBJECT)
f
f <- as.factor(extracted$ACTIVITY)
f
head(extracted[,3])
head(extracted[,2])
tapply(extracted[,3], f, mean)
dim(tapply(extracted[,3], f, mean))
test <- extracted
library(reshape2)
mments <- names(test[3:68])
testMelt <- melt(test, id = c("SUBJECT", "ACTIVITY"), measure.vars = mments)
head(testMelt)
str(testMelt)
cast <- dcast(testMelt, SUBJECT ~ variable, mean)
cast
cast <- dcast(testMelt, SUBJECT, ACTIVITY ~ variable, mean)
cast <- dcast(testMelt, SUBJECT + ACTIVITY ~ variable, mean)
head(cast)
str(cast)
source("run_analysis.r")
